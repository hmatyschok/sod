/*-
 * Copyright (c) 2015 Henning Matyschok
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materiasc provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * version=0.1 
 */

#include <sys/time.h>

#include <err.h>
#include <errno.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sysexits.h>
#include <syslog.h>

/*
 * Set contains abstract components.
 */

#include "sod_msg.h" 
#include "sod_thr.h"

/******************************************************************************
 * Prototypes, generic exception handler                                              *
 ******************************************************************************/

static void 	sod_syslog_thr(int, const char *, void *);
static void 	sod_exit_thr(int, const char *, void *);
static void 	sod_errx_thr(int, const char *, void *);

/******************************************************************************
 * Prototypes, private methods                                                *
 ******************************************************************************/
 
static void 	sod_lock_thr_exeption(struct sod_thr *);

/******************************************************************************
 * Prototypes, generic methods, accessible by promoted components             *
 ******************************************************************************/
 
static void 	sod_lock_thr(void *);
static void 	sod_unlock_thr(void *);
static int  	sod_bind_thr(void *, void *, void *);
static int 	sod_wait_thr(u_int, void *);

/******************************************************************************
 * Statically defined class-attributes.                                                    *
 ******************************************************************************/

static pthread_mutex_t 	mtx = PTHREAD_MUTEX_INITIALIZER;
static pthread_cond_t 	cv = PTHREAD_COND_INITIALIZER;
static pthread_attr_t 	attr;

static struct sod_thr libsod_thr = {
	.st_cookie 		= SOD_THR_COOKIE,
	
	.st_flags 		= (SOD_SYNC|SOD_SYSLOG),

	.st_type 		= SOD_THR_TYPE,
	.st_lock 		= sod_lock_thr,
	.st_unlock 		= sod_unlock_thr,
	.st_wait 		= sod_wait_thr,
};

/*
 * Generic component set initializer.
 */
int 
libsod_thr_include(struct sod_thr *cls, void *arg0, void *arg1)
{
	struct sod_header *sh1 = arg1;
	struct sod_header *sh0 = arg0;
	int eval = -1;
	
	sod_lock_thr(&libsod_thr);
	
	if ((libsod_thr.st_flags & SOD_INIT) == 0) {
/* 
 * Once called, ensures that call of pthread_join(3)
 * serializes pthread(3) execution sucessfully. 
 */
		if (pthread_attr_init(&attr) != 0)
			errx(EX_OSERR, "%s: pthread_attr_init: %s",  __func__, 
				strerror(errno));
	
		if (pthread_attr_setdetachstate(&attr, 
				PTHREAD_CREATE_JOINABLE) != 0)
			errx(EX_OSERR, "%s: pthread_attr_setdetachstate: %s", 
				__func__, strerror(errno));
/*
 * Any abstract component set must be mapped to itself.
 */ 		
		libsod_thr.st_flags |= SOD_INIT;
		libsod_thr.st_ref += 1;
	}	

	if ((libsod_thr.st_flags & SOD_INIT) && (libsod_thr.st_ref > 0)
		&& (sh1 != NULL) && (sh0 != NULL) && (cls != NULL)) { 
/*
 * A component set C is free generated by the inclusion 
 * mapping i of any x element in C into set A containing 
 * abstract components a, where C subset A.
 * 
 * Any mapping f between C and B (containing components) 
 * can be unequely extended to a morphism h between A 
 * and B of Sigma-algebras, where f < h.  
 */			
		if ((cls->st_cookie != libsod_thr.st_cookie)
			&& (cls->st_cookie == sh0->sh_cookie) 
			&& ((cls->st_flags & SOD_INIT) == 0) 
			&& (cls->st_ref == 0)) {

#ifdef SOD_DEBUG 
syslog(LOG_ERR, "%s: %s: inclusion\n", __func__, cls->st_type);				
#endif /* SOD_DEBUG */
				
/*
 * Initialize by caller requested class attributes.
 */
			cls->st_flags |= sh1->sh_flags;
			cls->st_mask = sh1->sh_mask;
/*
 * Declare C subset A.
 */			
			cls->st_flags |= SOD_INIT;
/*
 * Propagate cookie and increment reference count to indicate that i: C -> A.
 */		
			sh1->sh_cookie = cls->st_cookie;			
			
			libsod_thr.st_ref += 1;
			eval = 0;
		}
	}
	sod_unlock_thr(&libsod_thr);
	
	return (eval);	
}
 
/*
 * Generic component set finalizer.
 */ 
void 
libsod_thr_exclude(struct sod_thr *cls, void *arg)
{
	struct sod_thr_attr *sta = arg;
	struct sod_header *sh = arg;
	
	sod_lock_thr(&libsod_thr);
	
	if ((libsod_thr.st_flags & SOD_INIT) 
		&& (libsod_thr.st_ref > 0)
		&& (sta != NULL) && (cls != NULL)) {
		
		if ((cls->st_cookie != libsod_thr.st_cookie)
			&& (cls->st_cookie == sh->sh_cookie)
			&& (cls->st_flags & SOD_INIT)
			&& (cls->st_ref == 0)) {
/*
 * Exclude component subset.
 */					
			if (pthread_key_delete(sta->sta_key) == 0) { 

#ifdef SOD_DEBUG 
syslog(LOG_ERR, "%s: %s: exclusion\n", __func__, cls->st_type);				
#endif /* SOD_DEBUG */

				cls->st_flags &= ~SOD_INIT;
				libsod_thr.st_ref -= 1;
			}
		}
	}
	
	if ((libsod_thr.st_flags & SOD_INIT) && (libsod_thr.st_ref == 0)) {
/*
 * Exclude set of abstract components.
 */			
		if (pthread_attr_destroy(&attr) == 0)
			libsod_thr.st_flags &= ~SOD_INIT;	
	}
	
	sod_unlock_thr(&libsod_thr);		
}

/******************************************************************************
 * Generic constructor.                                                       *
 ******************************************************************************/

/*
 * An abstract component acts as factory for generating a component
 * x in C, due to given morphism h: A -> B of Sigma-algebras, where A 
 * denotes set of abstract components and B subset of A and C. 
 * 
 * This implies, that following preconditions must hold 
 * for successfull component instantiation:
 *  
 *  o B subset C and C subset A
 *  o i: C -> A, dom(i) subset A
 *  o f: C -> B, either dom(f) subset B or dom(f) equals B
 *  o h: A -> B, where B subset dom(h) 
 */
struct sod_thr *
sod_create_thr(struct sod_thr *cls0, sod_promote_thr_t sod_promote_thr, 
		void *arg)
{
	struct sod_header *sh = NULL;

	struct sod_thr *cls = NULL;
	struct sod_thr *st = NULL;

	if ((libsod_thr.st_flags & SOD_INIT) == 0)
		goto out;
/*
 * Apply various condition tests.
 */	
	if ((sh = arg) == NULL)
		goto out;
	
	if (sod_promote_thr == NULL)
		goto out;
	
	if ((cls = cls0) == NULL) 
		cls = &libsod_thr;
/*
 * An abstract component cannot instantiate itself.
 */
	if (cls->st_cookie == libsod_thr.st_cookie)
		goto out;
/*
 * Verify, if called component set exists.
 */	
	if (sh->sh_cookie != cls->st_cookie)
		goto out;

	if ((cls->st_flags & SOD_INIT) == 0)
		goto out;

	if (cls->st_size < SOD_THR_SIZE)
		goto out;

	if (cls->st_start == NULL) 
		goto out;
	
	if (cls->st_stop == NULL) 
		goto out;
/*
 * Allocate.
 */
	if ((st = calloc(1, cls->st_size)) == NULL)
		goto out;
/*
 * On success, initialize generic properties.
 */	
	st->st_cookie = cls->st_cookie;
	st->st_flags = cls->st_flags;
	st->st_type = cls->st_type;
	st->st_size = cls->st_size;
/*
 * Initialize generic methods and promote by requestor 
 * defined methods for pthread(3) life-cycle mangement.
 */ 
	st->st_start = cls->st_start;
	
	st->st_lock = (cls->st_lock) ? cls->st_lock : sod_lock_thr;
	st->st_unlock = (cls->st_unlock) ? cls->st_unlock : sod_unlock_thr;
	st->st_wait = (cls->st_wait) ? cls->st_wait : sod_wait_thr;
	st->st_bind = (cls->st_bind) ? cls->st_bind : sod_bind_thr;
	
	st->st_log = (cls->st_flags & SOD_SYSLOG) ? sod_syslog_thr : NULL;
	
	st->st_exit = (cls->st_exit) ? cls->st_exit : sod_exit_thr;
	st->st_errx = (cls->st_errx) ? cls->st_errx : sod_errx_thr;		
	
	st->st_stop = cls->st_stop;		
/*
 * Promote component specific attributes 
 * by caller declared callback.
 */			
	if ((*sod_promote_thr)(st, arg) < 0) 
		goto bad;
/*
 * If successful, then create running pthread(3) instance.
 */	
	if (pthread_create(&st->st_tid, &attr, st->st_start, st) != 0) 
		goto bad;
out:		
	return (st);
bad:
	(*st->st_stop)(st);
/*
 * Otherwise, release bound ressources.
 */	
	st = NULL;
	goto out;
}

/******************************************************************************
 * Generic destructor                                                         *
 ******************************************************************************/

/*
 * Release lock, if any and release by pthread(3) 
 * private data bound ressources.
 */
void
sod_delete_thr(struct sod_thr *cls0, void *arg)
{
	struct sod_thr *st = NULL;
	struct sod_thr *cls = NULL;

	if ((libsod_thr.st_flags & SOD_INIT) == 0)
		return;

	if ((st = arg) == NULL)
		return;
	
	if ((cls = cls0) == NULL) 
		st = &libsod_thr;
/*
 * An abstract component cannot be destroyed.
 */
	if (st->st_cookie == libsod_thr.st_cookie)
		return;
	
	if (st->st_cookie != cls->st_cookie)
		return;
/*
 * Verify, if focussed component set exists.
 */	
	if ((cls->st_flags & SOD_INIT) == 0)
		return;
	
	if (st->st_flags & SOD_LOCKED) 
		(*st->st_unlock)(st);
		
	if (st->st_ref < cls->st_ref) 
		cls->st_ref -= 1;
	
	(void)memset(arg, 0, st->st_size);
	free(arg);	
}

/******************************************************************************
 * Definitions, private methods                                              *
 ******************************************************************************/

/*
 * Exception handler for pthread(3) synchronization primitves. 
 */
static void 
sod_lock_thr_exeption(struct sod_thr *st0)
{
	st_excp_t st_excp = sod_errx_thr;
	struct sod_thr *st = NULL;

	if ((st = st0) == NULL)
		st = &libsod_thr;
	
	switch (errno) {
	case EDEADLK:
	case EPERM:
		if (st->st_exit != NULL)
			st_excp = st->st_exit;
		break;
	case EINVAL:
	default:
		if (st->st_errx != NULL)
			st_excp = st->st_errx;
		break;
	}
	
	(*st_excp)(EX_UNAVAILABLE, __func__, st);
}

/******************************************************************************
 * Definitions, generic methods, accessible by promoted components            *
 ******************************************************************************/

static void 	
sod_lock_thr(void *arg)
{
	struct sod_thr *st = NULL;
	
	if ((st = arg) == NULL)
		st = &libsod_thr;

#ifdef SOD_DEBUG
syslog(LOG_ERR, "%s: %s\n", __func__, st->st_type);	
#endif /* SOD_DEBUG */

	if (pthread_mutex_lock(&mtx) != 0) 
		sod_lock_thr_exeption(st);
		
	st->st_flags |= SOD_LOCKED;
}

static void 	
sod_unlock_thr(void *arg)
{
	struct sod_thr *st = NULL;
	
	if ((st = arg) == NULL)
		st = &libsod_thr;
	
#ifdef SOD_DEBUG
syslog(LOG_ERR, "%s: %s\n", __func__, st->st_type);	
#endif /* SOD_DEBUG */	
	
	if (pthread_mutex_unlock(&mtx) != 0) 
		sod_lock_thr_exeption(st);

	st->st_flags &= ~SOD_LOCKED;
}

/*
 * Bind by caller promoted class properties.
 */
static int  
sod_bind_thr(void *arg0, void *arg1, void *arg2)
{
	struct sod_thr *st = NULL;
	struct sod_header *sh = NULL;
	struct sod_thr_attr *sta = NULL;
	struct sod_thr *cls = NULL;
	int eval = -1;

	if ((st = arg2) == NULL)
		st = &libsod_thr;
/*
 * An abstract component is not runnable.
 */			
	if (st->st_cookie == libsod_thr.st_cookie)
		goto out;
	
	if ((sh = arg1) == NULL)
		sh = (void *)&libsod_thr;

	if (sh->sh_cookie != st->st_cookie)
		goto out;
		
	sta = arg1;	
		
	if ((cls = arg0) == NULL)
		cls = &libsod_thr;
		
	if (cls->st_cookie != sh->sh_cookie)
		goto out;

	if (cls->st_cookie != st->st_cookie)
		goto out;
 
	(*st->st_lock)(st);

	if (pthread_once(&sta->sta_once, sta->sta_init) != 0)
		(*st->st_errx)(EX_OSERR, __func__, st);
	
	while (sta->sta_eval & SOD_BIND_ERR) 	
		(*sta->sta_init)();
	
	eval = sta->sta_eval;	
	st->st_ref = cls->st_ref++;
	st->st_flags |= SOD_RUN;

#ifdef SOD_DEBUG
syslog(LOG_ERR, "%s: %s: %d in %d\n", __func__, 
	st->st_type, st->st_ref, cls->st_ref);	
#endif /* SOD_DEBUG */
		
	if (pthread_setspecific(sta->sta_key, st) != 0) 
		(*st->st_exit)(EX_OSERR, __func__, st);
		
	if (((st->st_flags & SOD_SYNC) == 0) 
		&& (st->st_flags & SOD_LOCKED)) 
		(*st->st_unlock)(st);	
out:
	return (eval);
}

/*
 * Fell asleep for ts seconds.
 */
static int 
sod_wait_thr(u_int ts, void *arg)
{
	struct sod_thr *st = NULL;
	
	u_int uts;	
	
	struct timespec ttw;
	struct timeval x;
	int eval = -1;
	
	if ((st = arg) == NULL) 
		goto out;
	
	if (st->st_cookie == libsod_thr.st_cookie)
		goto out;
	
	if ((st->st_flags & SOD_INIT) == 0)
		goto out;
	
	if ((uts = (ts * 1000)) == 0)
		goto out;
	
	if ((st->st_flags & SOD_SYNC) == 0) 
		(*st->st_lock)(st);
	
	st->st_flags &= ~SOD_RUN;
	
	while (eval < 0)
		eval = gettimeofday(&x, NULL);
	
	ttw.tv_sec = x.tv_sec + ts;
	ttw.tv_nsec = (x.tv_usec + uts) * 1000UL;
	
	eval = pthread_cond_timedwait(&cv, &mtx, &ttw);
	
	st->st_flags |= SOD_RUN;
	
	if ((st->st_flags & SOD_SYNC) == 0) 
		(*st->st_unlock)(st);
out:	
	return (eval);
}

/******************************************************************************
 * Definitions, generic exception handler                                      *
 ******************************************************************************/

static void 
sod_syslog_thr(int eval __unused, const char *s, void *arg)
{
	struct sod_header *sh = NULL;
	sod_tid_t tid = 0;
	
	if ((sh = arg) != NULL) 
		tid = sh->sh_tid;
		
	syslog(LOG_ERR, "thr: %ld: %s: %s", tid, s, strerror(errno));
}

/*
 * Abnormal pthread(3) termination.
 */
static void 
sod_exit_thr(int eval, const char *s, void *arg)
{
	sod_syslog_thr(eval, s, arg);
	pthread_exit(NULL);
}

/*
 * Abnormal process termination. 
 */
static void 
sod_errx_thr(int eval, const char *s, void *arg)
{	
	struct sod_thr *st = NULL;
	
	sod_syslog_thr(eval, s, arg);
	
	if (((st = arg) != NULL) 
		&& (st->st_stop != NULL)) 
		(*st->st_stop)(arg);

	exit(eval);
}
